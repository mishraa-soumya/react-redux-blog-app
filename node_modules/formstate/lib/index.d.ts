/** A truthy string or falsy values */
export declare type ValidationResponse = string | null | undefined | false;
/**
 * A validator simply takes a value and returns a string or Promise<string>
 * If a truthy string is returned it represents a validation error
 **/
export interface Validator<TValue> {
    (value: TValue): ValidationResponse | Promise<ValidationResponse>;
}
/**
 * Runs the value through a list of validators. As soon as a validation error is detected, the error is returned
 */
export declare function applyValidators<TValue>(value: TValue, validators: Validator<TValue>[]): Promise<string>;
/** Anything that provides this interface can be composed into the validation system */
export interface Validatable<TValue> {
    validating: boolean;
    validate(): Promise<{
        hasError: true;
    } | {
        hasError: false;
        value: TValue;
    }>;
    hasError: boolean;
    error?: string;
    $: TValue;
}
/**
 * Helps maintain the value + error information about a field
 *
 * This is the glue between the *page* and *field* in the presence of invalid states.
 */
export declare class FieldState<TValue> implements Validatable<TValue> {
    private config;
    /**
     * The value is stored in the field. May or may not be *valid*.
     */
    value: TValue;
    /** If there is any error on the field on last validation attempt */
    error?: string;
    /** The value set from code or a hot value that's been validated */
    $: TValue;
    private autoValidationEnabled;
    enableAutoValidationAndValidate: () => void;
    disableAutoValidation: () => void;
    constructor(config: {
        value: TValue;
        onUpdate?: (state: FieldState<TValue>) => any;
        validators?: Validator<TValue>[];
        autoValidationEnabled?: boolean;
        autoValidationDebounceMs?: number;
    });
    /** On change on the component side */
    onChange: (value: TValue) => void;
    /**
     * If the page wants to reinitialize the field with a new value,
     * it should call this function
     */
    reinitValue: (value: TValue) => void;
    readonly hasError: boolean;
    validating: boolean;
    /**
     * Runs validation on the current value immediately
     */
    private lastValidationRequest;
    validate: () => Promise<{
        hasError: true;
    } | {
        hasError: false;
        value: TValue;
    }>;
    /**
     * Runs validation with debouncing to keep the UI super smoothly responsive
     */
    private queueValidation;
    private onUpdate;
}
/** Each key of the object is a validatable */
export declare type ValidatableMapOrArray = {
    [key: string]: Validatable<any>;
} | Validatable<any>[];
/**
 * Just a wrapper around the helpers for a set of FieldStates or FormStates
 */
export declare class FormState<TValue extends ValidatableMapOrArray> implements Validatable<TValue> {
    /**
     * SubItems can be any Validatable
     */
    $: TValue;
    private mode;
    constructor(
        /**
         * SubItems can be any Validatable
         */
        $: TValue);
    /** Get validatable objects from $ */
    private getValues;
    validating: boolean;
    /**
     * - Re-runs validation on all fields
     * - returns `hasError`
     * - if no error also return the validated values against each key.
     */
    validate(): Promise<{
        hasError: true;
    } | {
        hasError: false;
        value: TValue;
    }>;
    /**
     * Does any field have an error
     */
    readonly hasError: boolean;
    /**
     * The first error from any sub if any
     */
    readonly error: string;
}
